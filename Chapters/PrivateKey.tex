\chapter{Private-Key}

\section{Asymptotic security}
\begin{definition}
    A scheme is \(\bracket{t,\epsilon}\)-secure if any adversary running for time at most \(t\) succeeds in breaking the scheme with probability at \(\epsilon\) at most.
\end{definition}
Consider the following definitions 
\begin{definition}
    An \textbf{efficient algorithm} (it might be probabilistic) runs in polynomial time, that is, there is \(p\) such that for all \(x \in \set{0,1}^{\ast}\), the alogrithm \(\func{A}{x}\) terminates in at most \(\func{p}{\abs{X}}\) steps.
\end{definition}

\begin{definition}
    \(f: \Naturals \to \Reals^+\) is \textbf{negligible} if
    \begin{equation*}
        \forall p \geq 0, \; \exists N \ \suchThat \ n \geq N \implies \func{f}{n} < \dfrac{1}{\func{p}{n}}
    \end{equation*}
\end{definition}

\begin{proposition}
    Suppose \(f,g\) are negligible then 
    \begin{enumerate}
        \item \(h = f + g\) is negligible.
        \item for \(p \geq 0 \), \(h = pf\) is negligible.
    \end{enumerate}
\end{proposition}
We can now define \textbf{asymptotic security} as 
\begin{definition}
    A scheme is secure if for every probabilistic polynomial time adversary \(\Adversary\) carrying out at attack from some formally specified type, the probability of \(\Adversary\) succeeding is negligible.
\end{definition}
Note that being negligible is asymptotic by definition.

\section{Computational security}
Let \(\Messages = \set{0,1}^{\ast}\) and \(\func{\Dec_k}{c}\) returns an error \(\but\) if \(c\) is invalid. If \(\forall k \gets \func{\Gen}{1^n}\), \(\Enc\) is only defined for \(m \in \set{0,1}^{\func{l}{n}}\), \(\Pi\) is a fixed-length private key encryption scheme for messages of length \(\func{l}{n}\). Furthermore, unless specified, we assume that \(\Enc\) and \(\Dec\) are \textit{stateless}. That is, each call is independent of previous calls. We revise the definition of \(\func{\PrivK_{\Adversary,\Pi}^{eav}}{n}\) so that \(\abs{m_0} = \abs{m_1}\). That is 
\begin{enumerate}
    \item \(\Adversary\) outputs a pair \(m_0,m_1 \in \Messages\) such that \(\abs{m_0} = \abs{m_1}\).
    \item \(k = \Gen\) and \(b\) - chosen from \(\set{0,1}\) uniformly - then the \textbf{challenge ciphertext} \(c = \func{\Enc_k}{m_b}\) is given to \(\Adversary\).
    \item \(\Adversary\) tries to determine the which message was encrypted and then outputs \(b'\).
    \item 
    \begin{equation*}
       \func{\PrivK_{\Adversary, \Pi}^{eav}}{n}
        \begin{cases}
           1 & b' = b \ \text{then}\  \Adversary \ \text{succeeds}\\
           0 & b' \neq b \  \text{then}\  \Adversary \ \text{fails}
        \end{cases}
    \end{equation*}
\end{enumerate}
Then the definition of indistinguishability becomes 
\begin{definition}
    \(\Pi\) has \textit{indistinguishable encryptions in presence of eavesdropper} or it is \textit{EAV-secure} if for any PPT \(\Adversary\) there is a negligible function such that
    \begin{equation*}
        \prob{\func{\PrivK_{\Adversary, \Pi}^{eav}}{n} = 1} = \frac{1}{2} + \func{negl}{n}
    \end{equation*}
\end{definition}

\begin{proposition}
    If \(b\) is fixed in the aforementioned EAV-security is equivalent to 
    \begin{equation*}
        \abs{\prob{\func{\PrivK_{\Adversary, \Pi}^{eav}}{n, b = 0} = 1} - \prob{\func{\PrivK_{\Adversary, \Pi}^{eav}}{n, b = 1} = 1}} \leq \func{negl}{n}
    \end{equation*}
\end{proposition}

\begin{theorem}
    Let \(\Pi\) be an EAV-secure fixed-length encryption scheme. Then for all PPT \(\Adversary\) and any bit \(m^i,\; i \in \set{1, \dots, l}\) there is a negligible function such that 
    \begin{equation*}
        \prob{\func{\Adversary}{1^n, \func{\Enc_k}{m}} = m^i} \leq \frac{1}{2} + \func{negl}{n}
    \end{equation*}
    That is, \(\Adversary\) can not determine any bit any better than guessing it.
\end{theorem}

\begin{proof}
    proof by reduction
\end{proof}

\begin{theorem}
    Let \(\Pi\) be defined as above. Then for any PPT \(\Adversary\), there is a PPT algorithm \(\Adversary'\) such that for any \(S \subset \set{0,1}^l\) and any function \(f : \set{0,1}^l \to \set{0,1}\), there is a negligible function such that 
    \begin{equation*}
        \abs{\prob{\func{\Adversary}{1^n, \func{\Enc_k}{m}} = \func{f}{m}} - \prob{\func{\Adversary'}{1^n} = \func{f}{m}}} \leq \func{negl}{n}
    \end{equation*}
    That is, no \(\Adversary\) can do any better finding a function of the message if they had the ciphertext than when they do not.
\end{theorem}

Lastly, we must take into account any external information \(\func{h}{m}\) about the plaintext that may be leaked.
\begin{definition}
    \(\Pi\) is sementically secure if \(\forall \Adversary, \; \exists \Adversary'\) (both are PPT) such that for any PPT algorithm \(Samp\) and polynomial time computable functions \(f\) and \(h\), 
    \begin{equation*}
        \abs{\prob{\func{\Adversary}{1^n, \func{\Enc_k}{m} , \func{h}{m}} = \func{f}{m}} - \prob{\func{\Adversary'}{1^n, \abs{m}, \func{h}{m}} = \func{f}{m}}}
    \end{equation*} 
    is negligible. That is, given the additionally leaked information, no \(\Adversary\) can do better finding a function of the message if they have the ciphertext than when when they don not have the ciphertext but know about the length of the message.
\end{definition}

\begin{theorem}
    \(\Pi\) is sementically secure if and only if it is EAV-secure.
\end{theorem}

\section{Pseudorandom generator}
A \textbf{pseudorandom generator} \(G\) is an efficient deterministic algorithm for transforming a short uniform string called seed, into a longer uniform-looking, pseudorandom, output string.
\begin{definition}
    Let a \(l\) be polynomial and \(G\) be a deterministic polynomial time algorithm such that \(\forall n, s \in \set{0,1}^n\), \(\func{G}{s}\) returns a string of length \(\func{l}{n}\). Then \(G\) is a pseudorandom random generator if 
    \begin{enumerate}
        \item \(\forall n, \; \func{l}{n} \geq n \). 
        \item For any PPT algorithm \(D\), there is a negligible function such that 
        \begin{equation*}
            \abs{\prob{\func{D}{\func{G}{s}} = 1} - \prob{\func{D}{r} = 1}} \leq \func{negl}{n}
        \end{equation*}
        where is \(r\) is taken uniformly from \(\set{0,1}^{\func{l}{n}}\)
    \end{enumerate}
\end{definition}

A \textbf{stream cipher} is pair of deterministic alogrithm \((Init, GetBits)\) where 
\begin{definition}
    \item[Init] takes as input a seed \(s\) and optional initialization vector IV, and outputs an initial state \(st_0\).
    \item[GetBits] takes as input state \(st_i\) and return a bit \(y\) and updated state \(st_{i + 1}\). 
\end{definition}

\section{Proof by reduction}
Assume \(X\) can not be solved by any polynomial time algorithm with negligible probability. Then to prove \(\Pi\) is secure we must show 
\begin{enumerate}
    \item Fix some efficient adversary \(\Adversary\) attacking \(\Pi\) with success probability \(\func{\epsilon}{n}\).
    \item Construct \(\Adversary'\) that attempts to solve \(X\) using \(\Adversary\) as a subroutine. Given an instance \(x\) of \(X\), \(\Adversary'\) simulates \(\Pi\) for \(\Adversary\) such that 
     \begin{enumerate}
        \item As far as \(\Adversary\) can tell, it is interacting with \(\Pi\).
        \item If \(\Adversary\) breaks \(\Pi\), this should allow \(\Adversary'\) to solve \(x\) at least with probability \(\frac{1}{\func{p}{n}}\) for some polynomial.
        
    \end{enumerate}
    \item Taken together, they imply that \(\Adversary'\) can solve \(X\) with probability \(\frac{\func{\epsilon}{n}}{\func{p}{n}}\). If \(\epsilon\) is not negligible then \(\frac{\epsilon}{p}\) is not negligible neither. Moreover, if \(\Adversary\) is efficient we obtain an efficient algorithm \(\Adversary'\) solving \(X\) with non-negligible probability, contradicting our assumptions.
    \item Given our assumption about \(X\) there is no efficient adversary \(\Adversary\) that can succeed in breaking with non-negligible probability. Meaning that \(\Pi\) is computationally secure.
\end{enumerate}

\section{Security for multiple encryptions}
Define \(\func{\PrivK_{\Adversary, \Pi}^{mult}}{n}\):
\begin{enumerate}
    \item \(\Adversary\) is given input \(1^n\) and output \(M_0 = (m_{0,1}, \dots , m_{0,n})\) and \(M_1 = (m_{1,1}, \dots , m_{1,n})\) with \(\abs{m_{0,i}} = \abs{m_{1,i}}, \; \forall i\).
    \item  \(k \gets \func{\Gen}{1^n}\) and \(b \in \set{0,1}\)  are chosen uniformly. \(C = (c_1, \dots, c_n)\) is constructed with \(c_i \gets \func{\Enc_k}{m_{b,i}}\)
    \item \(\Adversary\) outputs its guess \(b'\).
\end{enumerate}
Then \(\Pi\) is mult-secure if for all PPT \(\Adversary\) there is a negligible function such that 
\begin{equation*}
    \prob{\func{\PrivK_{\Adversary, \Pi}^{mult}}{n}} \leq \frac{1}{2} + \func{negl}{n}
\end{equation*}

\begin{proposition}
    \(\func{\PrivK_{\Adversary, \Pi}^{mult}}{n} \implies \func{\PrivK_{\Adversary, \Pi}^{eav}}{n}\), however, the converse is not true. 
\end{proposition}

\begin{proposition}
    If \(\Pi\) is stateless and \(\Enc\) is deterministic then \(\Pi\) can not be mult-secure.
\end{proposition}

\section{CPA and CPA-security}
Let \(\func{\PrivK_{\Adversary,\Pi}^{cpa}}{n}\)
\begin{enumerate}
    \item \(k \gets \func{\Gen}{1^n}\) unknown to \(\Adversary\).
    \item \(\Adversary\) is given \(1^n\) and \(\func{\Enc_k}{\cdot}\) and output messages \(m_0,m_1\) with \(\abs{m_0} = \abs{m_1}\).
    \item \(b \in \set{0,1}\) is chosen uniformly and \(c \gets \func{\Enc_k}{m_b}\) is given to \(\Adversary\).
    \item \(\Adversary\) ouptut \(b'\).
\end{enumerate}

\(\Pi\) is indistinguishable against CPA attacks, CPA-secure, if \(\forall \Adversary\) running in PPT there exists a negligible function such that 
\begin{equation*}
    \prob{\func{\PrivK_{\Adversary,\Pi}^{cpa}}{n} = 1} \leq \frac{1}{2} + \func{negl}{n}
\end{equation*}

which then can be extended to multiple messages by \(\func{\PrivK_{\Adversary,\Pi}^{LR-cpa}}{n}\). Instead of outputting lists of messages in this scheme attacker can sequentially query \(\Pi\). 
\begin{enumerate}
    \item \(k \gets \func{\Gen}{1^n}\) and \(b \in \set{0,1}\) is uniformly chosen, both unknown to \(\Adversary\).
    \item \(\Adversary\) is given \(1^n\) and \(\func{LR_{k,b}}{\cdot, \cdot}\).
    \item \(\Adversary\) ouptut \(b'\).
\end{enumerate}
where \(\func{LR_{k,b}}{m_0, m_1} = \func{\Enc_{k}}{m_b}\) with \(\abs{m_0}= \abs{m_1}\).

\(\Pi\) has indistinguishable multiple encryptions under CPA, CPA-secure for multiplie messages, if for any PPT \(\Adversary\) there exists a negligible function such that 
\begin{equation*}
    \prob{\func{\PrivK_{\Adversary,\Pi}^{LR-cpa}}{n} = 1} \leq \frac{1}{2} + \func{negl}{n}
\end{equation*}

\begin{theorem}
    CPA-secure is equivalent to CPA-secure for multiple messages.
\end{theorem}

\begin{corollary}
    CPA-security for fixed-length messages can be extended to arbitrary length.
\end{corollary}

\section{Pseudorandom function}
\(F: \set{0,1}^{\ast} \times \set{0,1}^{\ast} \to \set{0,1}^{\ast}\) is a key function \(\func{F}{k,x}\). We assume that \(k \in \set{0,1}^{\func{l_{key}}{n}}\), \(x \in \set{0,1}^{\func{l_{in}}{n}}\), and \(\func{F_k}{x} \in \set{0,1}^{\func{l_{out}}{n}}\) with \(\func{l_{key}}{n} = \func{l_{in}}{n} = \func{l_{out}}{n} = n\). \(F\) is a psuedorandom if the function for any uniformly chose \(k\), \(F_k\), is indistinguishable from a function chosen uniformly from the set of all functions having the same domain and range. That is, \(F\) is a pseudorandom function if for all polynomial-time distinguisher \(D\), there is a negligible function such that 
\begin{equation*}
    \abs{\prob{\func{D^{\func{F_k}{\cdot}}}{1^n} = 1} - \prob{\func{D^{\func{f}{\cdot}}}{1^n} = 1}} \leq \func{negl}{n}
\end{equation*}
where the first probability is taken over uniform \(k \in \set{0,1}^n\) and \(D\) and the second probability is taken over uniform \(f\) and \(D\). Note that \(D\) only evaluate \(F_k\) or \(f\) polynomially many times. \(F\) is a keyed permutation if \(l_{in} = l_{out}\) and \(\forall k \in \func{l_{key}}{n}\), \(F_k\) is a permutation. \(F\) is efficient if there is polynomial-time algorithm to compute \(\func{F_k}{x}, \ \forall k,x\) and \(\func{F^{-1}_k}{y}, \ \forall k,y\). 

\begin{proposition}
    If \(F\) is a permutation pseudorandom and \(\func{l_{in}}{n} \geq n\) then \(F\) is also a pseudorandom function.
\end{proposition}

\begin{definition}
    \(F\) is strong pseudorandom permutation if for all PPT distinguisher \(D\), there is a negligible function such that 
    \begin{equation*}
        \abs{\prob{\func{D^{\func{F_k}{\cdot}, \func{F_k^{-1}}{\cdot}}}{1^n} = 1} - \prob{\func{D^{\func{f}{\cdot}, \func{f^{-1}}{\cdot}}}{1^n} = 1}} \leq \func{negl}{n}
    \end{equation*}
\end{definition}

\begin{definition}
    Block ciphers are secure instances of strong pseudorandom permutations with some fixed key length and block length.
\end{definition}

--Construction of pseudorandom generators and stream ciphers from pseudorandom functions.

\begin{definition}
    CPA encryption with pseudorandom function can be achieved with 
    \begin{itemize}
        \item \(\Gen\) takes \(1^n\) and outputs \(k \in \set{0,1}^n\) uniformly.
        \item \(\Enc\) chooses uniform \(r \in \set{0,1}^n\) and outputs \(c = \angleBracket{r,\func{F_k}{r} \oplus m}\), where \(F\) is a pseudorandom function.
        \item \(\Dec\) takes \(k\) and \(c = \angleBracket{r,s}\) and outputs 
        \begin{equation*}
            m = \func{F_k}{r} \oplus s
        \end{equation*}
    \end{itemize}
\end{definition}

\begin{theorem}
    If \(F\) is a pseudorandom function, then the above Construction is a CPA-secure for messages of length \(n\).
\end{theorem}

\section{Modes of operation}
\subsection{Stream cipher}
\subsubsection{Synchronized mode}
It is good for single communication and messages that are send and recieved in order without being loss. 
-- insert shape
Let \(\func{G_{\infty}}{s , l}\) where \(s\) is the seed and \(l\) is the desired length, then
\begin{equation*}
    c = \func{G_{\infty}}{k,1^{\abs{m}}} \oplus m , \quad m = c \oplus \func{G_{\infty}}{k,1^{\abs{m}}}
\end{equation*}
Note that the message \(m\) can be composed of \(m_1 || m_2 || \dots \) and then we can calculate \(c\) by XORing the corresponding portion of \(G_{\infty}\) with \(m_i\). 
\begin{proposition}
    If stream cipher is indistinguishable this is EAV-secure.
\end{proposition}
\subsection{Unsynchronized mode}
We let \(G_{\infty}\) to take an initialization vector \(IV \in \set{0,1}^n\) as well. Note that \(IV\) and \(k\) are uniformly chosen. 
\begin{equation*}
    c = \angleBracket{IV, \func{G_{\infty}}{k,IV, 1^{\abs{m}}} \oplus m}
\end{equation*}
\begin{proposition}
    If there exists a weak pseudorandom function such that 
    \begin{equation*}
        \func{F_K}{IV} = \func{G_{\infty}}{k , IV, 1^l}
    \end{equation*}
    then the unsynchronized mode is CPA-secure.
\end{proposition}

\subsection{Block-cipher}
Let \(F\) be a block cipher with length \(n\). We assume that \(\abs{m}\) is a multiple of \(n\). That is \(m = m_1 || \dots || m_l\) with \(m_i \in \set{0,1}^n\)\_ if not we can append 1 followed by sufficiently many zeros.

\subsubsection{Electronic Code Block mode (EBC)}
\begin{align*}
    c &= \angleBracket{\func{F_K}{m_1}, \dots , \func{F_K}{m_l}}\\
    m &= \angleBracket{\func{F_K^{-1}}{c_1}, \dots , \func{F_K^{-1}}{c_l}}
\end{align*}
it is not even EAV-secure, because of repeated portions.

\subsubsection{Cipher Block Chaining (CBC)}
\begin{align*}
    c &= \angleBracket{c_0 = IV \in \set{0,1}^n , \func{F_K}{m_1 \oplus c_0}, \dots , \func{F_K}{m_l \oplus c_{l-1}}}\\
    m &= \angleBracket{\func{F_K^{-1}}{c_1} \oplus c_0 , \dots , \func{F_K^{-1}}{c_l} \oplus c_{l-1}}
\end{align*}
\begin{proposition}
    If \(F\) is a pseudorandom permutation then this is CPA secure.
\end{proposition}
Then chained (stateful) CBC variant uses that last \(c_l\) for encryption of new message \(m'\) instead of a fresh new \(IV\). However, chained CBC is vulenrable to CPA. Consider the following scheme 
\begin{enumerate}
    \item Attacker knows \(m_1 \in \set{m_1^0 , m_1^1}\).
    \item Attacker observes \(\angleBracket{IV,c_1,c_2,c_3}\).
    \item Attacker chooses \(m_4 = IV \oplus m_1^0 \oplus c_3\) and observes \(c_4\).
    \item \(m_1 = m_0^1 \iff c_1 = c_4\).
\end{enumerate}

\subsubsection{Output feedback mode (OFB)}
\begin{equation*}
    c = \angleBracket{IV,m_1 \oplus \func{F_K}{IV}, m_2 \oplus \func{F_K}{\func{F_K}{IV}} , \dots , m_l \oplus \func{F_K^{(l)}}{IV}}
\end{equation*}
\begin{proposition}
    OFB is CPA-secure if \(F\) is a pseudorandom function. To improve the efficiency we can calculate \(\func{F_K^{(n)}}{IV}\) ahead of time. Stateful variant is secure as well.
\end{proposition}

\subsubsection{Counter mode (CTR)}
Let \(ctr \in \set{0,1}^n\) be a uniformly chosen number then
\begin{equation*}
    c = \angleBracket{ctr, m_1 \oplus \func{F_K}{ctr + 1} , \dots , m_l \oplus \func{F_K}{ctr + l}}
\end{equation*}
\begin{proposition}
    CTR is CPA-secure if \(F\) is a pseudorandom function. 
\end{proposition}
Stateful version is secure as well. It can be parallelized.